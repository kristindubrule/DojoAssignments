<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>

</body>
	<script>
	function DoubleUpPointers (arr) {
		var origArrayPosition = arr.length-1;
		arr.length = arr.length*2;

		for (var i = arr.length-1; i >= 0; i-=2) {
			console.log(i);
			arr[i] = arr[origArrayPosition];
			arr[i-1] = arr[origArrayPosition];
			origArrayPosition--;
		}
		return arr;
	}
	console.log(DoubleUpPointers([7,4,10]));

	function DoubleUpMath (arr) {
		for (var i = arr.length-1; i >=0; i--) {
			arr[i*2] = arr[i];
			arr[i*2+1] = arr[i];
		}
		return arr;
	}

	console.log(DoubleUpMath([7,4,10]));

	function ReverseArray (arr) {
		for (var i = 0; i < arr.length/2; i++) {
			var temp = arr[i];
			arr[i] = arr[arr.length-i-1];
			arr[arr.length-i-1] = temp;
		}
		return arr;
	}
	console.log(ReverseArray([7,4,56,0,10]));

	function isSupervocalic(str) {
		var vowCounts = {
			a: 0,
			e: 0,
			i: 0,
			o: 0,
			u: 0
		};
		for (var i = 0; i < str.length; i++) {
			if (vowCounts[str[i]] != undefined) {
				vowCounts[str[i]]++;
			}
		}
		for (x in vowCounts) {
			if (vowCounts[x] != 1) {
				return false;
			}
		}
		return true;
	}
	console.log(isSupervocalic("pandemonium"));
	console.log(isSupervocalic("My name is Kristin"));

	function removeSpaces(str) {
		var newStr = "";
		for (var i = 0; i < str.length; i++) {
			if (str[i] != " ") {
				newStr += str[i];
			}
		}
		return newStr;
	}

	console.log(removeSpaces(""));
	console.log(removeSpaces("I"));
	console.log(removeSpaces("My name is Kristin"));
	console.log(removeSpaces("My    name is Kristin"));

	function acronymn(str) {
		var acronymnStr = "";
		if (str[0] != " ") {
			acronymnStr = str[0];
		}
		for (var i = 0; i < str.length; i++) {
			if (str[i-1] == " " && str[i] != " ") {
				acronymnStr += str[i].toUpperCase();
			}
		}
		return acronymnStr;
	}
	console.log(acronymn("My name is Kristin"));
	console.log(acronymn("  My name is Kristin"));
	console.log(acronymn("My name    is Kristin"));

	function sumToOne (num) {
		var sum = 0;

		while (Math.abs(num) >= 1) {
			sum += num%10;
			num /= 10;
			num = Math.trunc(num);
		}

		if (Math.abs(sum) < 10) {
			return sum;
		}
		return (sumToOne(sum));
	}

	console.log(sumToOne(928));
	console.log(sumToOne(10));
	console.log(sumToOne(5));
	console.log(sumToOne(-928));

	function countLetters (str) {
		var counts = {};

		for (var i in str) {
			var letter = str[i].toLowerCase();
			if (!counts[letter]) {
				counts[letter] = 1;
				console.log("False-y");
			} else {
				counts[letter] += 1;
			}
		}
		return counts;
	}

	console.log(countLetters("Hello"));

	function removeDupesUnsorted (arr) {
		var dupes = {};
		var dupe_indices = [];
		for (var i = 0; i < arr.length; i++) {
			if (dupes[arr[i]]) {
				dupes[arr[i]] = 1;
			}
			else {
				for (var j = i; j < arr.length; j++) {
					arr[j] = arr[j+1];
				}
				arr.pop();
			}
		}
	}

	function coinChange(legend, amount) {
		var change = {};
		var val_array = [];

		for (k in legend) {
			val_array.push(legend[k]);
		}
		val_array.sort();

		for (var i = (val_array.length)-1; i >= 0; i--) {
			var counter = 0;
			while (amount >= val_array[i]) {
				amount -= val_array[i];
				counter++;
			}
			for (k in legend) {
				if (legend[k] == val_array[i]) {
					change[k] = counter;
				}
			}
		}
		return change;
	}

	console.log("Return ",coinChange({"square": 3, "triangle": 1, "circle": 5},20));
	console.log("Return ",coinChange({"square": 3, "triangle": 1, "circle": 5},4));
	console.log("Return ",coinChange({"square": 3, "triangle": 1, "circle": 5},14));

	function validParens(str) {
		var counter = 0;
		for (var i = 0; i < str.length; i++) {
			if (str[i] == '(') {
				counter++;
			} else {
				counter--;
			}
			if (counter < 0) {
				break;
			}
		}
		return counter == 0;
	}

	console.log(validParens("(()())"));
	console.log(validParens("(()()"));
	console.log(validParens("(()())("));

	function validBraces(str) {
		var bracelog = [];
		var braceMatcher = { '{': '}', '(':')', '[':']'}
		for (var i = 0; i < str.length; i++) {
			if (str[i] == '{' || str[i] == '[' || str[i] == '(') {
				bracelog.push(str[i]);				
			}
			// Otherwise, it's a close brace; see if it's the matching close brace for the previous
			// open brace
			else if (str[i] == braceMatcher[bracelog[bracelog.length-1]] && bracelog.length > 0) {
				bracelog.pop();
			}
			else {
				return false;
			}
		}
		return bracelog.length == 0;
	}

	console.log("ValidBraces ", validBraces("(()())"));
	console.log("ValidBraces ", validBraces("(()()"));
	console.log("ValidBraces ", validBraces("{}()[]"));
	console.log("ValidBraces ", validBraces("{)}()[]"));

	function isPalindrome(str) {
		var isPal = true;
		var lowerstr = str.toLowerCase();
		var end = str.length-1;
		for (var begin = 0; begin < str.length; begin++) {
			while (lowerstr[begin] == ' ') {
				begin++;
			}
			while (lowerstr[end] == ' ') {
				end--;
			}
			console.log(begin, lowerstr[begin], lowerstr[end]);
			if (lowerstr[begin] != lowerstr[end]) {
				isPal = false;
				break;
			}
			if (begin >= end) {
				break;
			}
			end--;
		}
		return isPal
	}

	console.log(isPalindrome("A man a plan a canal Panama"))
	console.log(isPalindrome("The quick brown fox jumped over the lazy dog"))
	console.log(isPalindrome("1001"))
	console.log(isPalindrome("10001"))
	console.log(isPalindrome("1001"))
	console.log(isPalindrome("10001"))

	function isPrime(num) {
		for (var i = 2; i < num; i++) {
			if (num%i == 0) {
				return false;
			}
		}

	}

	/*
		All possible substrings
		Hello world

		h
		he
		hel
		hell
		hello
		e
		el
		ell
	*/
	function longestPalindrome(str) {
		var words = [];
		var longest = str[0];
		// For each character in the string
		for (var i = 0; i < str.length; i++) {
			var buildString = str[i];
			// Build each of the possible substrings starting with that character
			if (buildString.length+1 > longest.length 
				&& buildString.length+str.length-i > longest.length) {
				for (var j = i+1; j < str.length; j++) {
					buildString += str[j];
					if (buildString.length > longest.length) {
						var palindrome = true;
						for (var k = 0; k < buildString.length/2; k++) {
							if (buildString[k] != buildString[buildString.length-k-1]) {
								var palindrome = false;
								break;
							}
						}
						if (palindrome == true) {
							longest = buildString;
						}
					}
				}
			}
		}
		return longest;
	}

	console.log(longestPalindrome("hello world"));
	console.log(longestPalindrome("Yikes! my favorite racecar erupted!"));
	console.log(longestPalindrome("what up, daddy-o?"));

	function SLL() {
		this.head = null;
	}
	function Node(val) {
		this.val = val;
		this.next = null;
	}

	SLL.prototype.addToFront = function(val) {
		var node1 = new Node(val);
		node1.next = this.head;
		this.head = node1;
	}

	SLL.prototype.zip = function(list2) {
		var run1 = this.head;

		if (run1 == null) {
			return list2;
		}
		if (run2 == null) {
			return this;
		}

		while (run1 != null) {
			// If run2 is empty, we're done, and can return
			// the list so far
			if (run2 == null) {
				break;
			}

			// Insert node from run2
			var temp1 = run1.next;
			var temp2 = list2.head;


			list2.head = run1.next.next;
		}
		if (run2 != null) {
			run1.next = run2;
		}
	}

	SLL.prototype.zipGraham = function(list2) {
		var r1 = this.head;
		var r2 = list2.head;
		if (!r1) {
			this.head = r2;
		}
		while (r1 && list2.head) {
			var temp = r1.next;
			r1.next = r2;
			r1 = temp;
			temp = r2.next
			if (r1) {
				r2.next = r1;
			}
			list2.head = r2.next;
			r2 = temp;
		}
	}

	SLL.prototype.print = function() {
		var temp = this.head;
		while (temp != null) {
			console.log(temp.val);
			temp = temp.next;
		}
	}

	var list1 = new SLL();
	list1.addToFront(3);
	list1.addToFront(2);
	list1.addToFront(1);

	var list2 = new SLL();
	list2.addToFront('c');
	list2.addToFront('b');
	list2.addToFront('a');

	list1.zipGraham(list2);

	console.log("List 1");
	list1.print();
	console.log("List 2");
	list2.print();


	function rainTerrace(A) {
		var leftmost = []
		var rightmost = []

    	var leftMaxSoFar = 0;
	    for (var i = 0; i < A.length; i++) {
        	leftmost[i] = leftMaxSoFar;
        	if (A[i] > leftMaxSoFar) {
        		leftMaxSoFar = A[i];
        	}
    	}

	    //right exclusive scan, O(n), the highest bar to the right each point
	    var rightMaxSoFar = 0;
	    for (var i = A.length - 1; i >= 0; i--){
	        rightmost[i] = rightMaxSoFar;
	        if (A[i] > rightMaxSoFar) {
	        	rightMaxSoFar = A[i];
	        }
	    }

	    // Summation, O(n)
	    var vol = 0;
	    for (var i = 0; i < A.length-1; i++){
	        vol += Math.max(0, Math.min(leftmost[i], rightmost[i]) - A[i]);
	    }
	    return vol;
	}

	console.log(rainTerrace([3,1,2,4,1]))

	function reverseSLL() {

	}

	function returnKthSLL() {

	}

	function zibonacci(number) {
		if (number <= 1) {
			return 1;
		} else if (number == 2) {
			return 2;
		} else {
			halfnum = number/2;
			if (number%2 == 0) {
				return zibonacci(halfnum) + zibonacci(halfnum - 1) + 1;
			} else {
				return zibonacci(halfnum) + zibonacci(halfnum + 1) + 1;
			}
		}
	}

	console.log("Zibonacci 1 " + zibonacci(1));
	console.log("Zibonacci 2 " + zibonacci(2));
	console.log("Zibonacci 3 " + zibonacci(3));
	console.log("Zibonacci 4 " + zibonacci(4));
	console.log("Zibonacci 5 " + zibonacci(5));

	function rGCF(n1, n2) {
		if (n1 == n2) {
			return n1;
		} else if (n1 > n2) {
			return (n1 - n2*(Math.floor(n1/n2)-1),n2);
		} else {
			return (n1,n2 - n1*(Math.floor(n2/n1)-1));
		}
	}

	console.log("GCF 10,2 " + rGCF(10,2));
	console.log("GCF 123456,987654 " + rGCF(123456,987654));

	function allSubsets(str, substr=undefined, arr=undefined) {
		if (arr == undefined) {
			arr = [];
		}
		if (substr == undefined) {
			substr = "";
		}
		if (str == "") {
			arr.push(substr);
			console.log("Push substr " + substr);
			return arr;
		}
		var first = str[0];
		str = str.slice(1);
		console.log("Calling with str: " + str + " substring: " + substr + " arr: " + arr);
		allSubsets(str,substr,arr);
		console.log("Calling with str: " + str + " substring: " + substr+first + " arr: " + arr);
		allSubsets(str,substr+first,arr);
		return arr;
	}

	console.log("All subsets abc '" + allSubsets("abc").join("','") + "'");

	function binaryStringExpansion(str) {
		var retArray = [""];
		for (var i = 0; i < str.length; i++) {
			console.log("for loop");
			if (str[i] == "?") {
				var initialLength = retArray.length;
				for (var j = 0; j < initialLength; j++) {
					retArray.push(retArray[j] + "0");
					retArray[j] += "1";
				}
			} else {
				for (var j = 0; j < retArray.length; j++) {
					retArray[j] += str[i];
				}
			}
		}
		return retArray;
	}

	console.log("1?0? " + binaryStringExpansion("1?0?"));

		function binaryStringExpansion2(str) {
		var retArray = [""];
		for (var i = 0; i < str.length; i++) {
			var initialLength = retArray.length;
			for (var j = 0; j < initialLength; j++) {
				if (str[i] == "?") {
					retArray.push(retArray[j] + "0");
					retArray[j] += "1";
				} else {
					retArray[j] += str[i];
				}
			}
		}
		return retArray;
	}

	console.log("1?0? " + binaryStringExpansion2("1?0?"));

	function calculateSquare(n, start=undefined)
    {
    	if (start == undefined) {
    		start = n;
    	}
		// odds ascending and evens descending
        if(n <= 0) {
        	return;
        }
        if (start == n) {
        	if (n%2 == 0) {
	        	calculateSquare(n-1,start);
	        	console.log(n*n)
        		calculateSquare(n-2,start);
        	} else {
	        	calculateSquare(n-2,start);
	        	console.log(n*n)
        		calculateSquare(n-1,start);        		
        	}
        } else {
        	if (n%2 == 0) {
        		console.log(n*n);
        		calculateSquare(n-2,start);
        	} else {
        		calculateSquare(n-2,start);        		
        		console.log(n*n);
        	}
        }
    }

    console.log("5 rising squares:")
    calculateSquare(5);

    function calculateSquareWrap(n) {
    	calculateSquareDown((n%2 == 0) ? n-1 : n);
		calculateSquareUp((n%2 == 0) ? n : n-1);
    }
    function calculateSquareUp(n) {
    	if (n <= 0) {
    		return;
    	} else {
    		console.log(n*n);
    		calculateSquareUp(n-2);
    	}
    }
    function calculateSquareDown(n) {
    	if (n <= 0) {
    		return;
    	} else {
    		calculateSquareDown(n-2);
    		console.log(n*n);
    	}
    }
    console.log("5 rising squares w/ wrapper:")
    calculateSquareWrap(5);

    console.log("6 rising squares w/ wrapper:")
    calculateSquareWrap(6);

    function circQueue(capacity) {
    	this.capacity = capacity;
    	this.tail = null;
    	this.size = 0;
    }

    function circQueueNode(val) {
    	this.next = null;
    	this.val = val;
    }

    circQueue.prototype.enQueue = function(val) {
    	if (this.capacity == this.size) {
    		return false;
    	}
    	var node = new circQueueNode(val);
    	this.size += 1;
    	if (this.tail == null) {
    		this.tail = node;
    		node.next = node;
    	} else {
    		node.next = this.tail.next;
    		this.tail.next = node;
    		this.tail = node;
    	}
    	return true;
    }

    circQueue.prototype.print = function() {
    	var runner = this.tail.next;
    	while (runner != this.tail) {
    		console.log(runner.val);
    		runner = runner.next;
    	}
    	console.log(runner.val);
    }

    circQueue.prototype.deQueue = function(val) {
    	if (this.size == 0) {
    		return null;
    	}
    	var temp = this.tail.next.val;
    	this.tail.next = this.tail.next.next;
    	return temp;
    }

    var circQueue = new circQueue();
    console.log(circQueue.deQueue());
    circQueue.enQueue(1);
    circQueue.enQueue(2);
    circQueue.enQueue(3);
    circQueue.enQueue(4);
    console.log("Queue");
    circQueue.print();
    circQueue.deQueue();
    console.log("Queue after deQueue");
    circQueue.print();
    circQueue.enQueue(5);
    console.log("Queue after enQueue");
    circQueue.print();

    function circQueueArr(capacity) {
    	this.capacity = capacity;
    	this.head = -1;
    	this.tail = -1;
    	this.arr = [];
    }

	circQueueArr.prototype.enQueueArr = function(val) {
		// If the tail is in the last slot & the head is in the first slot
		// or the tail is one slot before the head, we're full
		if ((this.tail == this.capacity-1 && this.head == 0) || (this.tail == this.head-1)) {
			return false;
		} else if (this.head == -1) { // Inserting the first element
			this.head = 0;
			this.tail = 0;
			this.arr[this.tail] = val;
		} else if (this.tail == this.capacity-1 && this.head != 0) { // If the tail is in the last slot but the head is not in the first, wrap
			this.tail = 0;
			this.arr[this.tail] = val;
		} else { // Otherwise, we're just adding a value to the end of the array
			this.tail += 1;
			this.arr[this.tail] = val;
		}

		return true;
	}

	circQueueArr.prototype.deQueueArr = function(val) {
		if (this.head == -1) {
			return null;
		}

		var temp = this.arr[this.head];
		this.arr[this.head] = null;

		// If that was the only element, reset the head & tail
		if (this.head == this.tail) {
			this.head = -1;
			this.tail = -1;
		}
		// If head was on the last slot, put it to the first slot
		else if (this.head == this.capacity-1) {
			this.head = 0;
		}

		// Otherwise, just move the head forward
		else {
			this.head += 1;
		}
		return temp;
	}

	circQueueArr.prototype.printArr = function() {
		var runner = this.head;
		while (runner != this.tail) {
			console.log(this.arr[runner]);
			if (runner == this.capacity-1) {
				runner = 0;
			} else {
				runner += 1;
			}
		}
		console.log(this.arr[runner]);
	}

    var circQueueArr = new circQueueArr(4);
    console.log(circQueueArr.deQueueArr());
    circQueueArr.enQueueArr(1);
    console.log("Queue head " + circQueueArr.head + " tail " + circQueueArr.tail);
    circQueueArr.enQueueArr(2);
    circQueueArr.enQueueArr(3);
    circQueueArr.enQueueArr(4);
    console.log("Queue");
    circQueueArr.printArr();
    circQueueArr.deQueueArr();
    console.log("Queue after deQueue");
    circQueueArr.printArr();
    console.log("Queue head " + circQueueArr.head + " tail " + circQueueArr.tail);
    circQueueArr.enQueueArr(5);
    console.log("Queue after enQueue");
    circQueueArr.printArr();
    console.log("Queue head " + circQueueArr.head + " tail " + circQueueArr.tail);
    circQueueArr.enQueueArr(10);
    console.log("Queue after enQueue (full)");
    circQueueArr.printArr();
    console.log("Queue head " + circQueueArr.head + " tail " + circQueueArr.tail);
    circQueueArr.deQueueArr();
    circQueueArr.enQueueArr(10);
    console.log("Queue after deQueue & enQueue");
    circQueueArr.printArr();

    console.log("Queue head " + circQueueArr.head + " tail " + circQueueArr.tail);

    function MinHeap() {
    	this.arr = [null];
    }

    MinHeap.prototype.parentVal = function(childIndex) {
    	return this.arr[Math.floor(childIndex/2)];
    }

    MinHeap.prototype.parentIndex = function(childIndex) { 
    	return Math.floor(childIndex/2);
    }

    MinHeap.prototype.swap = function(index1,index2) {
    	let temp = this.arr[index1];
    	this.arr[index1] = this.arr[index2];
    	this.arr[index2] = temp;
    }

    MinHeap.prototype.add = function(val) {
    	this.arr.push(val);

    	// val will be in this.arr.length-1
    	// val's parent will be Math.floor(this.arr[arr.length-1]/2)
    	let childIndex = this.arr.length-1;
    	while (this.parentVal(childIndex) && this.arr[childIndex] < this.parentVal(childIndex)) {
    		this.swap(childIndex,this.parentIndex(childIndex));
    	}
    }

    //          3
    //       5         9
    //    10   12   20  17
    // Heap has 7 nodes
    // Height is 3
    MinHeap.prototype.print = function() {
    	let n = 1;
    	console.log("*********");
    	while (this.arr[n]) {
    		console.log(this.arr[n]);
    		n += 1;
    	}
    }

    MinHeap.prototype.remove = function() {
    	this.arr[1] = this.arr[this.arr.length-1];
    	this.arr.pop();
    	this.repairDown(1);
    }

    MinHeap.prototype.repairDown = function(index) {
    	if (!this.arr[2*index] && !this.arr[2*index+1]) {
    		return;
    	} else if (!this.arr[2*index] && this.arr[index] > this.arr[2*index+1]) {
    		this.swap(2*index+1,index);
    		this.repairDown(2*index+1);
    	} else if (this.arr[index] > this.arr[2*index]) {
    		this.swap(2*index,index);
    		this.repairDown(2*index);
    	} else {
    		return;
    	}
    }

  //   function repairUp(arr, index) {
  //   	if (index > 0 || arr[index] <= arr[Math.floor(index/2)]) {
  //   		return;	
  //   	}
  //   	console.log("swapping " + );
  //   	let temp = arr[index];
  //   	arr[index] = arr[Math.floor(index/2)];
  //   	arr[Math.floor(index/2)] = temp;
		// repairUp(arr, Math.floor(index/2));
  //   }

    function heapify(arr) {
    	arr.push(arr[0]);
    	arr[0] = 'x';
    	let parent = Math.floor((arr.length-1)/2);
    	while (parent > 0) {
    		siftDown(arr, parent, arr.length-1);
    		parent -= 1;
    	}
    }

    function siftDown(arr, start, end) {
    	let largest = start;
    	let left = start * 2;
    	let right = start * 2 + 1;

    	if (left <= end && arr[left] > arr[largest]) {
    		largest = left;
    	}

    	if (right <= end && arr[right] > arr[largest]) {
    		largest = right;
    	}

    	if (start != largest) {
    		let temp = arr[start];
    		arr[start] = arr[largest];
    		arr[largest] = temp;
    		siftDown(arr, largest, end);
    	} else {
    		return;
    	}
    }

    function heapSort(arr) {
    	heapify(arr);

    	for (let i = arr.length-1; i > 0; i--) {
    		let temp = arr[1];
    		arr[1] = arr[i];
    		arr[i] = temp;
    		console.log("before sift: i = " + i + " arr: " + arr);
    		siftDown(arr, 1, i-1);
    		console.log("after sift: i = " + i + " arr: " + arr);
    	}
    }

    let h = new MinHeap();
    h.add(3);
    h.print();

    h.add(4);
    h.print();

    h.add(2);
    h.add(10);
    h.add(8);
    h.print();

    h.remove();
    h.print();

    let arrtoheap = [5,8,1,3,13,7];
    heapify(arrtoheap);
    console.log("Heapified " + arrtoheap);

    let arrtosort = [5,8,1,3,13,7];
    heapSort(arrtosort);
    console.log("Sorted " + arrtosort);

	</script>
</html>